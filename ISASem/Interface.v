
Require Import Strings.String.
Require Import stdpp.unstable.bitvector.
Require Import stdpp.countable.
Require Import stdpp.finite.
Require Import stdpp.gmap.

Require Import SSCCommon.Options.
Require Import SSCCommon.CBase.
Require Import SSCCommon.Effects.
Require Import SSCCommon.FMon.
Require Import SSCCommon.CResult.
Require Import SSCCommon.CBool.
Require Import SSCCommon.CBitvector.
Require Import SSCCommon.CDestruct.

(** * The architecture requirements *)

(** The architecture parameters that must be provided to the interface *)
Module Type Arch.

  (** The type of registers, most likely string, but may be more fancy *)
  Parameter reg : Type.

  (** We need to implement a gmap indexed by registers *)
  Parameter reg_eq : EqDecision reg.
  #[export] Existing Instance reg_eq.
  Parameter reg_countable : @Countable reg reg_eq.
  #[export] Existing Instance reg_countable.

  (** The type of registers. This needs to be a type generic enough to contain
      the value of any register.

      TODO: Decide if an architecture should provide a standard default value *)
  Parameter reg_type : Type.
  Parameter reg_type_eq : EqDecision reg_type.
  #[export] Existing Instance reg_type_eq.
  Parameter reg_type_countable : @Countable reg_type reg_type_eq.
  #[export] Existing Instance reg_type_countable.
  Parameter reg_type_inhabited : Inhabited reg_type.
  #[export] Existing Instance reg_type_inhabited.


  (** Register access kind (architecture specific) *)
  Parameter reg_acc : Type.

  Parameter reg_acc_eq : EqDecision reg_acc.
  #[export] Existing Instance reg_acc_eq.


  (** Virtual address size *)
  Parameter va_size : N.

  (** Physical addresses type. Since models are expected to be architecture
      specific in this, there is no need for a generic way to extract a
      bitvector from it*)
  Parameter pa : Type.

  (** We need to implement a gmap indexed by pa *)
  Parameter pa_eq : EqDecision pa.
  #[export] Existing Instance pa_eq.
  Parameter pa_countable : @Countable pa pa_eq.
  #[export] Existing Instance pa_countable.

  (** Add an offset to a physical address. Can wrap if out of bounds *)
  Parameter pa_addZ : pa → Z → pa.

  (** This need to behave sensibly.
      For fancy words: pa_addZ need to be an action of the group Z on pa *)
  Parameter pa_addZ_assoc :
    ∀ pa z z', pa_addZ (pa_addZ pa z) z' = pa_addZ pa (z + z')%Z.
  Parameter pa_addZ_zero : ∀ pa, pa_addZ pa 0 = pa.
  #[export] Hint Rewrite pa_addZ_assoc : arch.
  #[export] Hint Rewrite pa_addZ_zero : arch.

  Parameter pa_diffZ : pa → pa → option Z.
  Parameter pa_addZ_diffZ:
    ∀ pa pa' z, pa_diffZ pa' pa = Some z → pa_addZ pa z = pa'.


  (** Memory access kind (architecture specific) *)
  Parameter mem_acc : Type.

  Parameter mem_acc_eq : EqDecision mem_acc.
  #[export] Existing Instance mem_acc_eq.

  (** Is this access an explicit access, e.g. whose access was explicitely
      required by the instruction. As minimima, this must be not an IFetch or a TTW
      access *)
  Parameter is_explicit : mem_acc → bool.
  (** Is this access an instruction fetch read *)
  Parameter is_ifetch : mem_acc → bool.
  (** Is this access a translation table walk *)
  Parameter is_ttw : mem_acc → bool.
  (** Is this access relaxed, aka. no acquire or release strength *)
  Parameter is_relaxed : mem_acc → bool.
  (** Is this an acquire or a release access (Depending on whether this is a
      read or write *)
  Parameter is_rel_acq : mem_acc → bool.
  (** Is this a weak PC acquire (not ordered after write release *)
  Parameter is_acq_rcpc : mem_acc → bool.
  (** Is this a standalone access, aka. not part of an exclusive or RMW pair.
      This is based on the access type, so an unmatched exclusive load would not be
      "standalone" *)
  Parameter is_standalone : mem_acc → bool.
  (** Is this an exclusive access *)
  Parameter is_exclusive : mem_acc → bool.
  (** Is this part of an RMW instruction. Another RMW access to the same address
      in the same instruction is expected *)
  Parameter is_atomic_rmw : mem_acc → bool.


  (** Translation summary *)
  Parameter translation : Type.

  Parameter translation_eq : EqDecision translation.
  #[export] Existing Instance translation_eq.

  (** Abort description. This represent physical memory aborts on memory
      accesses, for example when trying to access outside of physical memory
      range. Those aborts are generated by the model*)
  Parameter abort : Type.

  (** Barrier types *)
  Parameter barrier : Type.

  Parameter barrier_eq : EqDecision barrier.
  #[export] Existing Instance barrier_eq.


  (** Cache operations (data and instruction caches) *)
  Parameter cache_op : Type.

  Parameter cache_op_eq : EqDecision cache_op.
  #[export] Existing Instance cache_op_eq.

  (** TLB operations *)
  Parameter tlb_op : Type.

  Parameter tlb_op_eq : EqDecision tlb_op.
  #[export] Existing Instance tlb_op_eq.

  (** Fault type for a fault raised by the instruction (not by the concurrency model)
      In Arm terms, this means any synchronous exception decided by the ISA model *)
  Parameter fault : Type -> Type.

  Parameter fault_eq : ∀ deps, EqDecision deps → EqDecision (fault deps).
  #[export] Existing Instance fault_eq.

End Arch.

(** * The Interface *)

Module Interface (A : Arch).
  Import A.

  (** Virtual address are tag-less bitvectors *)
  Definition va := bv va_size.

  (** Memory access kind *)
  Notation accessKind := mem_acc.

  (** The list of all physical addresses accessed when accessing [pa] with size
      [n] *)
  Definition pa_range pa n := seq 0 n |> map (λ n, pa_addZ pa (Z.of_nat n)).

  Lemma pa_range_length pa n : length (pa_range pa n) = n.
  Proof. unfold pa_range. by autorewrite with list. Qed.

  (** ** Memory read request *)
  Module ReadReq.
    #[local] Open Scope N.
    Record t {deps : Type} {n : N} :=
      make
        { pa : pa;
          access_kind : accessKind;
          va : option va;
          translation : translation;
          tag : bool;
          addr_deps : deps;
        }.
    Arguments t : clear implicits.

    Definition set_deps {d1 d2 : Type} {n : N} (f : d1 -> d2) (rr : t d1 n)
      : t d2 n :=
      {|
        pa := rr.(pa);
        access_kind := rr.(access_kind);
        va := rr.(va);
        translation := rr.(translation);
        tag := rr.(tag);
        addr_deps := f rr.(addr_deps);
        |}.

    Definition setv_deps {d1 d2 : Type} {n : N} (adeps : d2) (rr : t d1 n) :=
      set_deps (fun _ => adeps) rr.

    #[global] Instance eq_dec `{EqDecision deps} n : EqDecision (t deps n).
    Proof. solve_decision. Defined.

    #[global] Instance jmeq_dec `{EqDecision deps} : EqDepDecision (t deps).
    Proof. intros ? ? ? [] []. decide_jmeq. Defined.

    Definition range {deps n} (rr : t deps n) := pa_range (pa rr) (N.to_nat n).
  End ReadReq.

  (** ** Memory write request *)
  Module WriteReq.
    #[local] Open Scope N.
    Record t {deps : Type} {n : N} :=
      make
        { pa : pa;
          access_kind : accessKind;
          value : bv (8 * n);
          va : option va;
          translation : A.translation;
          tag : option bool;
          addr_deps : deps;
          data_deps : deps;
        }.
    Arguments t : clear implicits.

    Definition set_deps {d1 d2 : Type} {n : N} (f : d1 -> d2) (wr : t d1 n)
      : t d2 n :=
      {|
        pa := wr.(pa);
        access_kind := wr.(access_kind);
        value := wr.(value);
        va := wr.(va);
        translation := wr.(translation);
        tag := wr.(tag);
        addr_deps := f wr.(addr_deps);
        data_deps := f wr.(data_deps);
        |}.

    Definition setv_deps {d1 d2 : Type} {n : N} (adeps ddeps : d2)
      (wr : t d1 n) : t d2 n:=
      {|
        pa := wr.(pa);
        access_kind := wr.(access_kind);
        value := wr.(value);
        va := wr.(va);
        translation := wr.(translation);
        tag := wr.(tag);
        addr_deps := adeps;
        data_deps := ddeps;
        |}.

    #[global] Instance eq_dec `{EqDecision deps} n : EqDecision (t deps n).
    Proof. solve_decision. Defined.

    #[global] Instance jmeq_dec `{EqDecision deps} : EqDepDecision (t deps).
    Proof. intros ? ? ? [] []. decide_jmeq. Defined.

    Definition range {deps n} (rr : t deps n) := pa_range (pa rr) (N.to_nat n).
  End WriteReq.


  (** ** Outcomes*)
  Section Interface.
    (** The Interface is parametric over the type use to represent dependencies.
        In particular this type can be unit for an ISA model that does not
        contain any dependency information *)
    Context {deps : Type}.

    (** The effect type used by ISA models *)
    Inductive outcome : eff :=
      (** Reads a register [reg] with provided access type [racc]. It is up to
          concurrency model to interpret [racc] properly *)
    | RegRead (reg : reg) (racc : reg_acc) : outcome reg_type

      (** Write a register [reg] with value [reg_val] and access type [racc].
          The dependencies [deps] should describe the data flow into that
          register value. *)
    | RegWrite (reg : reg) (racc : reg_acc) (deps : deps)
        (regval: reg_type) : outcome unit
      (** Read [n] bytes of memory in a single access (Single Copy Atomic in Arm
          terminology). See [ReadReq.t] for the various required fields.

          The result is either a success (value read and optional tag) or a
          error (intended for physical memory errors, not translation, access
          control, or segmentation faults *)
    | MemRead (n : N) : ReadReq.t deps n →
                        outcome (bv (8 * n) * option bool + abort)%type
      (** Write [n] bytes of memory in a single access (Single Copy Atomic in
          Arm terminology). See [WriteReq.t] for the various required fields.

          If the result is:
          - inl true: The write happened
          - inl false: The write didn't happened because the required strength
            could not be achieved (e.g. exclusive failure)
          - inr abort: The write was attempted, but a physical abort happened
           *)
    | MemWrite (n : N) : WriteReq.t deps n → outcome (bool + abort)%type
      (** Declare the opcode of the current instruction when known. Used for
          dependency computations, and some other cases *)
    | InstrAnnounce (opcode : bvn) : outcome unit
      (** Declare a conditional branch to a new physical address [pa]. [deps]
          represent the data-flow into the conditional decision to take that
          branch. Unconditional branched do not need to be announced *)
    | BranchAnnounce (pa : pa) (deps : deps) : outcome unit
      (** Issues a barrier such as DMB (for Arm), fence.XX (for RISC-V), ... *)
    | Barrier : barrier -> outcome unit
      (** Issues a cache operation such as DC or IC (for Arm) *)
    | CacheOp (deps : deps) : cache_op → outcome unit
      (** Issues a TLB maintenance operation, such as TLBI (for Arm) *)
    | TlbOp (deps : deps) : tlb_op → outcome unit
      (** Take an exception. The [fault] type constructor make depend on a value
          whose data-flow can be encoded in the deps type *)
    | TakeException : fault deps → outcome unit
      (** Return from an exception to this address e.g. ERET (for Arm) or
          IRET (for x86) *)
    | ReturnException (pa : pa) : outcome unit

      (** Bail out when something went wrong. This is to represent ISA model
          incompleteness: When getting out of the range of supported
          instructions or behaviors of the ISA model. The string is for
          debugging but otherwise irrelevant *)
    | GenericFail (msg : string) : outcome noreturn.
    Arguments outcome _%type.

    #[global] Instance outcome_wf : Eff.Wf outcome.
    Proof using. intros T []; apply _. Qed.


    (* Automatically implies EqDecision (outcome T) on any T *)
    #[global] Instance outcome_eff_dec `{EqDecision deps} : Eff.Decision outcome.
    Proof using. intros ? ? [] []; decide_eff_eq. Defined.

    #[global] Program Instance outcome_exc : Eff.Exc outcome :=
      { exc := string;
        exc2eff := λ s, existT _ (GenericFail s);
        eff2exc := λ _ x,
          match x return option string with
          | GenericFail s => Some s
          | _ => None
          end
      }.
    Next Obligation. hauto qb:on. Qed.
    Next Obligation.
      intros. cbn.
      case_split; try (apply Eff.exc_empty_helper); sfirstorder.
    Qed.



    (** An instruction semantic is a non-deterministic program using the
        uninterpreted effect type [outcome] *)
    Definition iMon := cMon outcome.

    (** The semantics of an complete instruction. A full definition of
        instruction semantics is allowed to have an internal state that gets
        passed from one instruction to the next. This is useful to handle
        pre-computed instruction semantics (e.g. Isla). For complete instruction
        semantics, we expect that A will be unit.

        This is planned to disappear and be replaced by a plain [iMon ()], so
        some modules (like CandidateExecutions) will already assume [iMon ()].
        *)
    Record iSem :=
      {
        (** The instruction model internal state *)
        isa_state : Type;
        (** The instruction model initial state for a thread with a specific Tid
            *)
        init_state : nat -> isa_state;
        semantic : isa_state -> iMon isa_state
      }.

    (** A single event in an instruction execution. Events cannot contain
        termination outcome (outcomes of type `outcome False`)

        IEvent cannot be used a pattern in a match anymore, sorry, use FEvent
        instead *)
    Definition iEvent := fEvent outcome.
    Definition IEvent {T} : outcome T → T → iEvent := @FEvent outcome T.

    (** An execution trace for a single instruction.
        If the result is an A, it means a successful execution that returned A
        If the result is a string, it means a GenericFail *)
    Definition iTrace (A : Type) : Type := list iEvent * result string A.

    Definition iTrace_match {A : Type} (f : iMon A) (tr : iTrace A) :=
      cmatch f (fTrace_list_res_full tr.1 tr.2).

  End Interface.

  Arguments outcome _%type _%type : clear implicits.
  Arguments iMon : clear implicits.
  Arguments iSem : clear implicits.
  Arguments iTrace : clear implicits.
  Arguments iEvent : clear implicits.


  (** * Event accessors

     A set of accessors over the iEvent type *)

  (** Get the register out of a register event *)
  Definition get_reg `(ev : iEvent deps) : option reg :=
    match ev with
    | RegRead reg _ &→ _ => Some reg
    | RegWrite reg _ _ _ &→ _ => Some reg
    | _ => None
    end.

  (** Get a register and its value out of a register event

      This gives both the register and the value, because later the value might
      have a type that depend on the register *)
  Definition get_reg_val `(ev : iEvent deps) : option (reg * reg_type) :=
    match ev with
    | RegRead reg _ &→ regval => Some (reg, regval)
    | RegWrite reg _ _ regval &→ _ => Some (reg, regval)
    | _ => None
    end.

  Lemma get_reg_val_get_reg `(ev : iEvent deps) rrv :
    get_reg_val ev = Some rrv → get_reg ev = Some rrv.1.
  Proof. destruct ev as [? [] ?]; hauto lq:on. Qed.

  (** Get the physical address out of an memory event *)
  Definition get_pa `(e : iEvent deps) : option pa:=
    match e with
    | MemRead _ rr &→ _ => Some rr.(ReadReq.pa)
    | MemWrite _ wr &→ _ => Some wr.(WriteReq.pa)
    | _ => None
    end.

  (** Get the size out of an memory event *)
  Definition get_size `(ev : iEvent deps) : option N :=
    match ev with
    | MemRead n _ &→ _ => Some n
    | MemWrite n _ &→ _ => Some n
    | _ => None
    end.

  (** Get the value out of a memory event *)
  Definition get_mem_value `(ev : iEvent deps) : option bvn :=
    match ev with
    | MemRead n _ &→ inl (bv, _) => Some (bv : bvn)
    | MemWrite n wr &→ _ => Some (wr.(WriteReq.value) : bvn)
    | _ => None
    end.

  Lemma get_mem_value_size `(ev : iEvent deps) bv :
    get_mem_value ev = Some bv → get_size ev = Some (bvn_n bv / 8)%N.
  Proof.
    destruct ev as [? [] ?];
      cdestruct_intro #CDestrCbnSubst #CDestrMatch; cbn; f_equal; lia.
  Qed.

  (** Get the content of a barrier, returns none if not a barrier (or is an
        invalid EID) *)
  Definition get_branch_pa `(ev : iEvent deps) : option pa:=
    match ev with
    | BranchAnnounce pa _ &→ () => Some pa
    | _ => None
    end.

  (** Get the content of a barrier, returns none if not a barrier (or is an
        invalid EID) *)
  Definition get_barrier `(ev : iEvent deps) : option barrier:=
    match ev with
    | Barrier b &→ () => Some b
    | _ => None
    end.

  (** Get the content of a cache operation, returns none if not a cache operation
        (or is an invalid EID) *)
  Definition get_cacheop `(ev : iEvent deps) : option cache_op :=
    match ev with
    | CacheOp _ co &→ () => Some co
    | _ => None
    end.

  (** Get the content of a TLB operation, returns none if not a TLB operation
        (or is an invalid EID) *)
  Definition get_tlbop `(ev : iEvent deps) : option tlb_op :=
    match ev with
    | TlbOp _ to &→ () => Some to
    | _ => None
    end.



  (** * Event manipulation

     This is a set of helper function to manipulate events *)


  (** ** Register reads ***)

  Section isReg.
    Context (P : reg → reg_acc → reg_type → Prop).
    Context {deps : Type}.
    Implicit Type ev : iEvent deps.

    Definition is_reg_readP ev : Prop :=
      match ev with
      | RegRead reg racc &→ rval => P reg racc rval
      | _ => False
      end.
    #[export] Typeclasses Opaque is_reg_readP.
    Definition is_reg_readP_spec ev :
      is_reg_readP ev ↔
        ∃ reg racc rval, ev = RegRead reg racc &→ rval ∧ P reg racc rval.
    Proof. destruct ev as [? [] ?]; split; cdestruct_intro;naive_solver. Qed.
    Definition is_reg_readP_cdestr ev := cdestr_simpl (is_reg_readP_spec ev).
    #[global] Existing Instance is_reg_readP_cdestr.

    Context `{Pdec: ∀ reg racc rval, Decision (P reg racc rval)}.
    #[global] Instance is_reg_readP_dec ev: Decision (is_reg_readP ev).
    Proof using Pdec. destruct ev as [? [] ?]; tc_solve. Qed.

    (** ** Register writes *)
    Definition is_reg_writeP ev : Prop :=
      match ev with
      | RegWrite reg racc _ rval &→ _ => P reg racc rval
      | _ => False
      end.

    Definition is_reg_writeP_spec ev :
      is_reg_writeP ev ↔
        ∃ reg racc deps rval,
          ev = RegWrite reg racc deps rval &→ () ∧ P reg racc rval.
    Proof.
      destruct ev as [? [] fret];
        split; cdestruct_intro; destruct fret; naive_solver.
    Qed.
    Definition is_reg_writeP_cdestr ev := cdestr_simpl (is_reg_writeP_spec ev).
    #[global] Existing Instance is_reg_writeP_cdestr.

    #[global] Instance is_reg_writeP_dec ev: Decision (is_reg_writeP ev).
    Proof using Pdec. destruct ev as [? [] ?]; tc_solve. Qed.

  End isReg.
  Notation is_reg_read := (is_reg_readP (λ _ _ _, True)).
  Notation is_reg_write := (is_reg_writeP (λ _ _ _, True)).

  (** ** Memory reads *)

  (** *** Memory reads request

      This is the general case for both failed and successful memory reads *)
  Section isMemReadReq.
    Context {deps: Type}.
    Context
    (P : ∀ n : N, ReadReq.t deps n → (bv (8 * n) * option bool + abort) → Prop).
    Implicit Type ev : iEvent deps.

    Definition is_mem_read_reqP ev : Prop :=
      match ev with
      | MemRead n rr &→ rres => P n rr rres
      | _ => False
      end.
    #[export] Typeclasses Opaque is_mem_read_reqP.

    Definition is_mem_read_reqP_spec ev:
      is_mem_read_reqP ev ↔ ∃ n rr rres, ev = MemRead n rr &→ rres ∧ P n rr rres.
    Proof. destruct ev as [? [] ?]; split; cdestruct_intro; naive_solver. Qed.
    Definition is_mem_read_reqP_cdestr ev := cdestr_simpl (is_mem_read_reqP_spec ev).
    #[global] Existing Instance is_mem_read_reqP_cdestr.

    Context `{Pdec : ∀ n rr rres, Decision (P n rr rres)}.
    #[global] Instance is_mem_read_reqP_dec ev : Decision (is_mem_read_reqP ev).
    Proof using Pdec. destruct ev as [? [] ?]; tc_solve. Qed.
  End isMemReadReq.
  Notation is_mem_read_req := (is_mem_read_reqP (λ _ _ _, True)).

  (** *** Successful memory reads *)
  Section IsMemRead.
    Context {deps: Type}.
    Context (P : ∀ n : N, ReadReq.t deps n → bv (8 * n) → option bool → Prop).
    Implicit Type ev : iEvent deps.

    (** Filters memory read that are successful (that did not get a physical
        memory abort *)
    Definition is_mem_readP ev : Prop :=
      is_mem_read_reqP (λ n rr rres,
          match rres with
          | inl (rval, otag) => P n rr rval otag
          | _ => False end) ev.
    Typeclasses Opaque is_mem_readP.

    Definition is_mem_readP_spec ev:
      is_mem_readP ev ↔
        ∃ n rr rval otag, ev = MemRead n rr &→ inl (rval, otag) ∧ P n rr rval otag.
    Proof. unfold is_mem_readP. rewrite is_mem_read_reqP_spec. hauto l:on. Qed.
    Definition is_mem_readP_cdestr ev := cdestr_simpl (is_mem_readP_spec ev).
    #[global] Existing Instance is_mem_readP_cdestr.

    Context `{Pdec: ∀ n rr rval otag, Decision (P n rr rval otag)}.
    #[global] Instance is_mem_readP_dec ev: Decision (is_mem_readP ev).
    Proof using Pdec. unfold is_mem_readP. solve_decision. Qed.
  End IsMemRead.
  Notation is_mem_read := (is_mem_readP (λ _ _ _ _, True)).

  (** ** Memory writes *)

  (** *** Memory write requests

      This is the general case for both failed and successful memory writes. *)
  Section isMemWriteReq.
    Context {deps: Type}.
    Context
      (P : ∀ n : N, WriteReq.t deps n → (bool + abort) → Prop).
    Implicit Type ev : iEvent deps.

    Definition is_mem_write_reqP ev : Prop :=
      match ev with
      | MemWrite n wr &→ wres => P n wr wres
      | _ => False
      end.
    Typeclasses Opaque is_mem_write_reqP.

    Definition is_mem_write_reqP_spec ev:
      is_mem_write_reqP ev ↔ ∃ n wr wres, ev = MemWrite n wr &→ wres ∧ P n wr wres.
    Proof. destruct ev as [? [] ?]; split; cdestruct_intro; naive_solver. Qed.
    Definition is_mem_write_reqP_cdestr ev := cdestr_simpl (is_mem_write_reqP_spec ev).
    #[global] Existing Instance is_mem_write_reqP_cdestr.

    Context `{Pdec: ∀ n wr wres, Decision (P n wr wres)}.
    #[global] Instance is_mem_write_reqP_dec ev: Decision (is_mem_write_reqP ev).
    Proof using Pdec. destruct ev as [? [] ?]; tc_solve. Qed.
  End isMemWriteReq.
  Notation is_mem_write_req := (is_mem_write_reqP (λ _ _ _, True)).

  (** *** Successful memory writes *)
  Section isMemWrite.
    Context {deps: Type}.
    Context
      (P : ∀ n : N, WriteReq.t deps n → Prop).
    Implicit Type ev : iEvent deps.

    (** Filters memory writes that are successful (that did not get a physical
        memory abort). This might still not have written in case of exclusive
        failure *)
    Definition is_mem_writeP ev: Prop :=
      is_mem_write_reqP (λ n wr wres,
          match wres with
          | inl true => P n wr
          | _ => False end) ev.
    Typeclasses Opaque is_mem_writeP.

    Definition is_mem_writeP_spec ev:
      is_mem_writeP ev ↔
        ∃ n wr, ev = MemWrite n wr &→ inl true ∧ P n wr.
    Proof. unfold is_mem_writeP. rewrite is_mem_write_reqP_spec. hauto l:on. Qed.

    Context `{Pdec: ∀ n wr, Decision (P n wr)}.
    #[global] Instance is_mem_writeP_dec ev: Decision (is_mem_writeP ev).
    Proof using Pdec. unfold is_mem_writeP. solve_decision. Qed.
  End isMemWrite.
  Notation is_mem_write := (is_mem_writeP (λ _ _, True)).

  Definition is_mem_event `(ev : iEvent deps) :=
    is_mem_read ev \/ is_mem_write ev.

  Notation is_branch ev := (is_Some (get_branch_pa ev)).
  Notation is_barrier ev := (is_Some (get_barrier ev)).
  Notation is_cacheop ev := (is_Some (get_cacheop ev)).
  Notation is_tlbop ev := (is_Some (get_tlbop ev)).

End Interface.

Module Type InterfaceT (A : Arch).
  Include Interface A.
End InterfaceT.

Module Type InterfaceWithArch.
  Declare Module Arch : Arch.
  Include Arch.
  Include Interface Arch.
End InterfaceWithArch.
