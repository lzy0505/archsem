
Require Import Strings.String.
Require Import stdpp.unstable.bitvector.
Require Import stdpp.countable.
Require Import stdpp.finite.
Require Import stdpp.gmap.

(* This is needed because sail cannot export into multiple Coq files *)
Require Import SailArmInstTypes.

Require Import SSCCommon.Options.
Require Import SSCCommon.CBase.
Require Import SSCCommon.Effects.
Require Import SSCCommon.FMon.
Require Import SSCCommon.CResult.
Require Import SSCCommon.CBool.


#[global] Instance Explicit_access_kind_dec : EqDecision Explicit_access_kind.
Proof. solve_decision. Defined.

#[global] Instance Access_kind_dec `{EqDecision arch_ak} : EqDecision (Access_kind arch_ak).
Proof. solve_decision. Defined.

Local Open Scope stdpp_scope.
Local Open Scope Z_scope.

(** The architecture parameters that must be provided to the interface *)
Module Type Arch.

  (** The type of registers, most likely string, but may be more fancy *)
  Parameter reg : Type.

  (** We need to implement a gmap indexed by registers *)
  Parameter reg_eq : EqDecision reg.
  #[export] Existing Instance reg_eq.
  Parameter reg_countable : @Countable reg reg_eq.
  #[export] Existing Instance reg_countable.

  (** The type of registers. This needs to be a type generic enough to contain
      the value of any register.

      TODO: Decide if an architecture should provide a standard default value *)
  Parameter reg_type : Type.
  Parameter reg_type_eq : EqDecision reg_type.
  #[export] Existing Instance reg_type_eq.
  Parameter reg_type_inhabited : Inhabited reg_type.
  #[export] Existing Instance reg_type_inhabited.


  (** Register access kind (architecture specific) *)
  Parameter reg_acc : Type.

  Parameter reg_acc_eq : EqDecision reg_acc.
  #[export] Existing Instance reg_acc_eq.


  (** Virtual address size *)
  Parameter va_size : N.

  (** Physical addresses type. Since models are expected to be architecture
      specific in this, there is no need for a generic way to extract a
      bitvector from it*)
  Parameter pa : Type.

  (** We need to implement a gmap indexed by pa *)
  Parameter pa_eq : EqDecision pa.
  #[export] Existing Instance pa_eq.
  Parameter pa_countable : @Countable pa pa_eq.
  #[export] Existing Instance pa_countable.

  (** Add an offset to a physical address. Can wrap if out of bounds *)
  Parameter pa_addZ : pa → Z → pa.

  (** This need to behave sensibly.
      For fancy words: pa_addZ need to be an action of the group Z on pa *)
  Parameter pa_addZ_assoc :
    ∀ pa z z', pa_addZ (pa_addZ pa z) z' = pa_addZ pa (z + z')%Z.
  Parameter pa_addZ_zero : ∀ pa, pa_addZ pa 0 = pa.
  #[export] Hint Rewrite pa_addZ_assoc : arch.
  #[export] Hint Rewrite pa_addZ_zero : arch.

  (** Parameter for extra architecture specific access types. Can be an empty
      type if not used *)
  Parameter arch_ak : Type.
  Parameter arch_ak_eq : EqDecision arch_ak.
  #[export] Existing Instance arch_ak_eq.


  (** Translation summary *)
  Parameter translation : Type.

  Parameter translation_eq : EqDecision translation.
  #[export] Existing Instance translation_eq.

  (** Abort description. This represent physical memory aborts on memory
      accesses, for example when trying to access outside of physical memory
      range. Those aborts are generated by the model*)
  Parameter abort : Type.

  (** Barrier types *)
  Parameter barrier : Type.

  Parameter barrier_eq : EqDecision barrier.
  #[export] Existing Instance barrier_eq.


  (** Cache operations (data and instruction caches) *)
  Parameter cache_op : Type.

  Parameter cache_op_eq : EqDecision cache_op.
  #[export] Existing Instance cache_op_eq.

  (** TLB operations *)
  Parameter tlb_op : Type.

  Parameter tlb_op_eq : EqDecision tlb_op.
  #[export] Existing Instance tlb_op_eq.

  (** Fault type for a fault raised by the instruction (not by the concurrency model)
      In Arm terms, this means any synchronous exception decided by the ISA model *)
  Parameter fault : Type -> Type.

  Parameter fault_eq : ∀ deps, EqDecision deps → EqDecision (fault deps).
  #[export] Existing Instance fault_eq.

End Arch.

Module Interface (A : Arch).
  Import A.

  Definition va := bv va_size.
  Definition accessKind := Access_kind arch_ak.

  Definition pa_range pa n := seq 0 n |> map (λ n, pa_addZ pa (Z.of_nat n)).
  Lemma pa_range_length pa n : length (pa_range pa n) = n.
  Proof. unfold pa_range. by autorewrite with list. Qed.

  Module ReadReq.
    Record t {deps : Type} {n : N} :=
      make
        { pa : pa;
          access_kind : accessKind;
          va : option va;
          translation : translation;
          tag : bool;
          addr_deps : deps;
        }.
    Arguments t : clear implicits.

    Definition set_deps {d1 d2 : Type} {n : N} (f : d1 -> d2) (rr : t d1 n)
      : t d2 n :=
      {|
        pa := rr.(pa);
        access_kind := rr.(access_kind);
        va := rr.(va);
        translation := rr.(translation);
        tag := rr.(tag);
        addr_deps := f rr.(addr_deps);
        |}.

    Definition setv_deps {d1 d2 : Type} {n : N} (adeps : d2) (rr : t d1 n) :=
      set_deps (fun _ => adeps) rr.

    #[global] Instance eqdec `{EqDecision deps} n : EqDecision (t deps n).
    Proof. solve_decision. Defined.

    Definition range {deps n} (rr : t deps n) := pa_range (pa rr) (N.to_nat n).
  End ReadReq.

  Module WriteReq.
    Record t {deps : Type} {n : N} :=
      make
        { pa : pa;
          access_kind : accessKind;
          value : bv (8 * n);
          va : option va;
          translation : A.translation;
          tag : bool;
          addr_deps : deps;
          data_deps : deps;
        }.
    Arguments t : clear implicits.

    Definition set_deps {d1 d2 : Type} {n : N} (f : d1 -> d2) (wr : t d1 n)
      : t d2 n :=
      {|
        pa := wr.(pa);
        access_kind := wr.(access_kind);
        value := wr.(value);
        va := wr.(va);
        translation := wr.(translation);
        tag := wr.(tag);
        addr_deps := f wr.(addr_deps);
        data_deps := f wr.(data_deps);
        |}.

    Definition setv_deps {d1 d2 : Type} {n : N} (adeps ddeps : d2)
      (wr : t d1 n) : t d2 n:=
      {|
        pa := wr.(pa);
        access_kind := wr.(access_kind);
        value := wr.(value);
        va := wr.(va);
        translation := wr.(translation);
        tag := wr.(tag);
        addr_deps := adeps;
        data_deps := ddeps;
        |}.

    #[global] Instance eqdec `{EqDecision deps} n : EqDecision (t deps n).
    Proof. solve_decision. Defined.

    Definition range {deps n} (rr : t deps n) := pa_range (pa rr) (N.to_nat n).
  End WriteReq.

  Section T.
    Context {deps : Type}.

  Inductive outcome : eff :=
    (** reg_acc kind *)
  | RegRead (reg : reg) (racc : reg_acc) : outcome reg_type

    (** The direct or indirect flag is to specify how much coherence is required
        for relaxed registers.

        The dep_on would be the dependency of the register write.

        Generally, writing the PC introduces no dependency because control
        dependencies are specified by the branch announce *)
  | RegWrite (reg : reg) (racc : reg_acc) (deps : deps)
             (regval: reg_type) : outcome unit
  | MemRead (n : N) : ReadReq.t deps n →
                      outcome (bv (8 * n) * option bool + abort)%type
  | MemWrite (n : N) : WriteReq.t deps n → outcome (option bool + abort)%type
    (** Declare the opcode of the current instruction when known. Used for
        dependency computation *)
  | InstrAnnounce (opcode : bvn) : outcome unit
    (** The deps here specify the control dependency *)
  | BranchAnnounce (pa : pa) (deps : deps) : outcome unit
  | Barrier : barrier -> outcome unit
  | CacheOp (deps : deps) : cache_op → outcome unit
  | TlbOp (deps : deps) : tlb_op → outcome unit
  | TakeException : fault deps → outcome unit
  | ReturnException (pa : pa) : outcome unit

  (** Bail out when something went wrong; this may be refined in the future.
      This is an ISA model triggered failure *)
  | GenericFail (msg : string) : outcome noreturn.
  Arguments outcome _%type.

  #[global] Instance outcome_wf : Eff.Wf outcome.
  Proof using. intros T []; apply _. Qed.

  (* Automatically implies EqDecision (outcome T) on any T *)
  #[global] Instance outcome_eff_dec `{EqDecision deps} : Eff.Decision outcome.
  Proof using. intros ? ? [] []; decide_eff_eq. Qed.


  #[global] Program Instance outcome_exc : Eff.Exc outcome :=
    { exc := string;
      exc2eff := λ s, existT _ (GenericFail s);
      eff2exc := λ _ x,
          match x return option string with
          | GenericFail s => Some s
          | _ => None
          end
    }.
  Next Obligation. hauto qb:on. Qed.
  Next Obligation.
    intros. cbn.
    case_split; try (apply Eff.exc_empty_helper); sfirstorder.
  Qed.



  (** An instruction semantic is a non-deterministic program using the
      uninterpreted effect familly [outcome] *)
  Definition iMon := cMon outcome.

  (** The semantics of an complete instruction. A full definition of instruction
      semantics is allowed to have an internal state that gets passed from one
      instruction to the next. This is useful to handle pre-computed instruction
      semantics (e.g. Isla). For complete instruction semantics, we expect that
      A will be unit.*)
  Record iSem :=
    {
      (** The instruction model internal state *)
      isa_state : Type;
      (** The instruction model initial state for a thread with a specific Tid
          *)
      init_state : nat -> isa_state;
      semantic : isa_state -> iMon isa_state
    }.

  (** A single event in an instruction execution. Events cannot contain
      termination outcome (outcomes of type `outcome False`)

      IEvent cannot be used a pattern in a match anymore, sorry, use FEvent
      instead *)
  Definition iEvent := fEvent outcome.
  Definition IEvent {T} : outcome T → T → iEvent := @FEvent outcome T.

  (** An execution trace for a single instruction.
      If the result is an A, it means a successful execution that returned A
      If the result is a string, it means a GenericFail *)
  Definition iTrace (A : Type) : Type := list iEvent * result string A.

  Definition iTrace_match {A : Type} (f : iMon A) (tr : iTrace A) :=
    cmatch f (fTrace_list_res_full tr.1 tr.2).

  End T.

  Arguments outcome _%type _%type : clear implicits.
  Arguments iMon : clear implicits.
  Arguments iSem : clear implicits.
  Arguments iTrace : clear implicits.
  Arguments iEvent : clear implicits.

End Interface.

Module Type InterfaceT (A : Arch).
  Include Interface A.
End InterfaceT.

Module Type InterfaceWithArch.
  Declare Module Arch : Arch.
  Include Arch.
  Include Interface Arch.
End InterfaceWithArch.
