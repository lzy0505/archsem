
Require Import Strings.String.
Require Import bitvector.bitvector.

Local Open Scope stdpp_scope.
Local Open Scope Z_scope.

(** For explicit memory accesses, this determines whether the access has some kind of
    extra synchronisation semantics *)
Inductive Access_variety :=
| AV_plain
| AV_exclusive
| AV_atomic_rmw.

(** For explicit memory accesses, this determines whether the access has
    extra release-acquire semantics, and which *)
Inductive Access_strength :=
| AS_normal
| AS_rel_or_acq (* Release or acquire *)
| AS_acq_rcpc (* Release-consistency with processor consistency *).


(** The access kind defines the type of access and thus the synchronisation
    requirements of an explicit memory access *)
Record Explicit_access_kind := {
    variety : Access_variety;
    strength : Access_strength
  }.

(** The different kinds of memory accesses *)
Inductive Access_kind :=
| AK_explicit : Explicit_access_kind -> Access_kind
| AK_ifetch : Access_kind
| AK_TTW : Access_kind.

(** The architecture parameters that must be provided to the interface *)
Module Type Arch.

  (** The type of registers, most likely string, but may be more fancy *)
  Parameter reg : Type.

  (** The type of each register, often `bv 64` but it may be smaller or be a
      boolean *)
  Parameter reg_type : reg -> Type.

  (** Virtual address size *)
  Parameter va_size : N.

  (** Physical addresses type. Since models are expected to be architecture
      specific in this, there is no generic way to extract a bitvector from it*)
  Parameter pa : Type.

  (** Translation summary *)
  Parameter translation : Type.

  (** Abort description. This represent physical memory aborts on memory
      accesses, for example when trying to access outside of physical memory
      range. Those aborts are generated by the model*)
  Parameter abort : Type.

  (** Barrier types *)
  Parameter barrier : Type.

  (** Cache operations (data and instruction caches) *)
  Parameter cache_op : Type.

  (** TLB operation *)
  Parameter tlb_op : Type.

  (** Fault type for a fault raised by the instruction (not by the model) *)
  Parameter fault : Type.
End Arch.

Module Interface (A : Arch).

  Module DepOn.
    Record t :=
      make
        {
          (** The list of registers the effect depends on. *)
          regs : list A.reg;
          (** The list of memory access the effect depends on. The number
              corresponds to the memory reads done by the instruction in the
              order specified by the instruction semantics. The indexing starts
              at 0. *)
          mem_reads : list N
        }.
  End DepOn.

  Module ReadReq.
    Record t (n : N) :=
      make
        { pa : A.pa;
          access_kind : Access_kind;
          va : option (bv A.va_size);
          translation : A.translation;
          tag : bool;
          (** The address dependency. If unspecified, it can be interpreted as
            depending on all previous registers and memory values that were read
            *)
          addr_dep_on : option DepOn.t;
        }.
  End ReadReq.

  Module WriteReq.
    Record t (n : N) :=
      make
        { pa : A.pa;
          access_kind : Access_kind;
          value : bv (8 * n);
          va : option (bv A.va_size);
          translation : A.translation;
          tag : bool;
          (** The address dependency. If unspecified, it can be interpreted as
            depending on all previous registers and memory values that were read
            *)
          addr_dep_on : option DepOn.t;
          (** The data dependency. If unspecified, it can be interpreted as
            depending on all previous registers and memory values that were read
            *)
          data_dep_on : option DepOn.t;
        }.

  End WriteReq.

  Inductive outcome : Type -> Type :=
    (** The direct or indirect flag is to specify how much coherence is required
        for relaxed registers *)
  | RegRead (reg : A.reg) (direct : bool) : outcome (A.reg_type reg)

    (** The direct or indirect flag is to specify how much coherence is required
        for relaxed registers.

        The dep_on would be the dependency of the register write.

        Generally, writing the PC introduces no dependency because control
        dependencies are specified by the branch announce *)
  | RegWrite (reg : A.reg) (direct : bool) (dep_on : option DepOn.t)
    : A.reg_type reg -> outcome unit
  | MemRead (n : N) : ReadReq.t n ->
                      outcome (bv (8 * n) * option bool + A.abort)
  | MemWrite (n : N) : WriteReq.t n -> outcome (option bool + A.abort)
  | MemWriteAnnounce (n : N) : A.pa -> outcome unit
    (** The deps here specify the control dependency *)
  | BranchAnnounce (pa : A.pa) (dep_on : option DepOn.t) : outcome unit
  | Barrier : A.barrier -> outcome unit
  | CacheOp : A.cache_op -> outcome unit
  | TlbOp : A.tlb_op -> outcome unit
  | FaultAnnounce : A.fault -> outcome unit
  | EretAnnounce : outcome unit

  (** Bail out when something went wrong; this may be refined in the future *)
  | GenericFail (msg : string) : outcome False

  (** Terminate the instruction successfully *)
  | Success : outcome False

  (** The next two outcomes are for handling non-determinism. Choose will branch
      the possible executions non-deterministically for every bitvector of
      size n. *)
  | Choose (n : N) : outcome (bv n)
  (** Discard means that the instruction could never have made the previous
      non-deterministic choices and the current execution can be silently
      discarded. *)
  | Discard : outcome False.

  (** The semantics of an instruction *)
  Inductive instr_sem :=
  | InstrSem {T : Type} : outcome T -> (T -> instr_sem) -> instr_sem.

  (** A single event in an instruction execution *)
  Inductive event :=
  | Event {T : Type} : outcome T -> T -> event.

  (** An execution trace for a single instruction.
      If the option is None, it means a successful execution
      If the option is Some, it means a GenericFail *)
  Definition instr_trace : Type := list event * option string.

  (** Definition of a trace matching a semantics *)
  Inductive trace_match : instr_sem -> instr_trace -> Prop :=
  | TMNext T (oc : outcome T) (f : T -> instr_sem) (obj : T) rest e :
    trace_match (f obj) (rest, e) ->
    trace_match (InstrSem oc f) ((Event oc obj) :: rest, e)
  | TMSuccess f : trace_match (InstrSem Success f) ([], None)
  | TMFailure f s : trace_match (InstrSem (GenericFail s) f) ([], Some s).

End Interface.

Module Dummy <: Arch.
  Definition reg := N.
  Bind Scope N_scope with reg.
  Definition reg_type (n : N) := bv 64.
  Definition va_size := 64%N.
  Definition pa := bv 64.
  Definition translation := unit.
  Definition barrier := unit.
  Definition abort := unit.
  Definition cache_op := unit.
  Definition tlb_op := unit.
  Definition fault := unit.
End Dummy.

Module DummyInterface := Interface Dummy.
