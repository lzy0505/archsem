(* This file was generated by Sail using source files from
https://github.com/riscv/sail-riscv which released under the license below.

RISCV Sail Model

This Sail RISC-V architecture model, comprising all files and
directories except for the snapshots of the Lem and Sail libraries
in the prover_snapshots directory (which include copies of their
licences), is subject to the BSD two-clause licence below.

Copyright (c) 2017-2025
   ahadali5000
   Alasdair Armstrong
   Alexander Richardson
   Aril Computer Corp., for contributions by Scott Johnson
   Ben Marshall
   Bicheng Yang
   Bilal Sakhawat
   Brian Campbell
   Chris Casinghino
   Christopher Pulte
   Codasip, for contributions by Tim Hutt, Martin Berger and Ben Fletcher
   dylux
   eroom1966
   Google LLC, for contributions by its employees
   Hesham Almatary
   Jan Henrik Weinstock
   Jessica Clarke
   Jon French
   Jordan Carlin
   Martin Berger
   Michael Sammler
   Microsoft, for contributions by Robert Norton-Wright and Nathaniel Wesley Filardo
   Muhammad Bilal Sakhawat
   Nathaniel Wesley Filardo
   Paul A. Clarke
   Peter Rugg
   Peter Sewell
   Philipp Tomsich
   Prashanth Mundkur
   Rafael Sene
   Rishiyur S. Nikhil (Bluespec, Inc.)
   Robert Norton-Wright
   Scott Johnson (Aril Inc.)
   Shaked Flur
   Thibaut Pérami
   Thomas Bauereiss
   VRULL GmbH, for contributions by its employees
   William McSpaddden
   Xinlai Wan

For a complete list of authors run this command (in sail-riscv, not ArchSem):

    git shortlog --summary --numbered --email

All rights reserved.

This software was developed by the above within the Rigorous
Engineering of Mainstream Systems (REMS) project, partly funded by
EPSRC grant EP/K008528/1, at the Universities of Cambridge and
Edinburgh.

This software was developed by SRI International and the University of
Cambridge Computer Laboratory (Department of Computer Science and
Technology) under DARPA/AFRL contract FA8650-18-C-7809 ("CIFV"), and
under DARPA contract HR0011-18-C-0016 ("ECATS") as part of the DARPA
SSITH research programme.

This project has received funding from the European Research Council
(ERC) under the European Union’s Horizon 2020 research and innovation
programme (grant agreement 789108, ELVER).

------------------------------------------------------------------

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in
   the documentation and/or other materials provided with the
   distribution.

THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.
*)


From stdpp Require Import base countable.
Require Eqdep.
Require Import SailStdpp.Base.
Require Import SailStdpp.Real.
Require Import SailStdpp.ConcurrencyInterfaceTypes.
From RecordUpdate Require Import RecordSet.
Import RecordSetNotations.

Import ListNotations.
Open Scope string.
Open Scope bool.
Open Scope Z.

Definition bits (n : Z) : Type := mword n.

Inductive barrier_kind :=
| Barrier_RISCV_rw_rw
| Barrier_RISCV_r_rw
| Barrier_RISCV_r_r
| Barrier_RISCV_rw_w
| Barrier_RISCV_w_w
| Barrier_RISCV_w_rw
| Barrier_RISCV_rw_r
| Barrier_RISCV_r_w
| Barrier_RISCV_w_r
| Barrier_RISCV_tso
| Barrier_RISCV_i.
Definition num_of_barrier_kind (arg_ : barrier_kind) : Z :=
  match arg_ with
  | Barrier_RISCV_rw_rw => 0
  | Barrier_RISCV_r_rw => 1
  | Barrier_RISCV_r_r => 2
  | Barrier_RISCV_rw_w => 3
  | Barrier_RISCV_w_w => 4
  | Barrier_RISCV_w_rw => 5
  | Barrier_RISCV_rw_r => 6
  | Barrier_RISCV_r_w => 7
  | Barrier_RISCV_w_r => 8
  | Barrier_RISCV_tso => 9
   | Barrier_RISCV_i => 10
   end.

Definition barrier_kind_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 10)*) : barrier_kind :=
   let l__0 := arg_ in
   if Z.eqb l__0 0 then Barrier_RISCV_rw_rw
   else if Z.eqb l__0 1 then Barrier_RISCV_r_rw
   else if Z.eqb l__0 2 then Barrier_RISCV_r_r
   else if Z.eqb l__0 3 then Barrier_RISCV_rw_w
   else if Z.eqb l__0 4 then Barrier_RISCV_w_w
   else if Z.eqb l__0 5 then Barrier_RISCV_w_rw
   else if Z.eqb l__0 6 then Barrier_RISCV_rw_r
   else if Z.eqb l__0 7 then Barrier_RISCV_r_w
   else if Z.eqb l__0 8 then Barrier_RISCV_w_r
   else if Z.eqb l__0 9 then Barrier_RISCV_tso
   else Barrier_RISCV_i.

Lemma barrier_kind_num_of_roundtrip (x : barrier_kind) : barrier_kind_of_num (num_of_barrier_kind x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_barrier_kind_injective (x y : barrier_kind) : num_of_barrier_kind x = num_of_barrier_kind y -> x = y.
  intro.
  rewrite <- (barrier_kind_num_of_roundtrip x).
  rewrite <- (barrier_kind_num_of_roundtrip y).
  congruence.
Qed.
Definition barrier_kind_eq_dec (x y : barrier_kind) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_barrier_kind x) (num_of_barrier_kind y) with
  | left e => left (num_of_barrier_kind_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition barrier_kind_beq (x y : barrier_kind) : bool :=
  Z.eqb (num_of_barrier_kind x) (num_of_barrier_kind y).
Lemma barrier_kind_beq_iff x y : barrier_kind_beq x y = true <-> x = y.
  unfold barrier_kind_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_barrier_kind_injective | congruence].
Qed.
Lemma barrier_kind_beq_refl x : barrier_kind_beq x x = true.
apply barrier_kind_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_barrier_kind : EqDecision barrier_kind := barrier_kind_eq_dec.
#[export]
Instance Countable_barrier_kind : Countable barrier_kind.
refine {|
  encode x := encode (num_of_barrier_kind x);
  decode x := z ← decode x; mret (barrier_kind_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite barrier_kind_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_barrier_kind : Inhabited barrier_kind := { inhabitant := Barrier_RISCV_rw_rw }.


Record RISCV_strong_access := { RISCV_strong_access_variety : Access_variety; }.
Arguments RISCV_strong_access : clear implicits.
#[export]
Instance Decidable_eq_RISCV_strong_access : EqDecision RISCV_strong_access.
   intros [x0].
   intros [y0].
  cmp_record_field x0 y0.
left; subst; reflexivity.
Defined.
#[export]
Instance Countable_RISCV_strong_access : Countable RISCV_strong_access.
refine {|
  encode x := encode (RISCV_strong_access_variety x);
  decode x := '(x0) ← decode x;
              mret (Build_RISCV_strong_access x0)
|}.
abstract (
  intros [x0];
  rewrite decode_encode;
  reflexivity).
Defined.

#[export] Instance eta_RISCV_strong_access : Settable _ := settable! Build_RISCV_strong_access <RISCV_strong_access_variety>.
#[export]
Instance dummy_RISCV_strong_access : Inhabited (RISCV_strong_access) := {
  inhabitant := {| RISCV_strong_access_variety := inhabitant
|} }.
